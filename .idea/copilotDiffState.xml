<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/server/__tests__/routes.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/__tests__/routes.test.ts" />
              <option name="originalContent" value="import { describe, it, expect, beforeAll, afterAll, jest } from '@jest/globals';&#10;import request from 'supertest';&#10;import express from 'express';&#10;import { registerRoutes } from '../routes';&#10;import axios from 'axios';&#10;&#10;describe('SEO Analyzer API', () =&gt; {&#10;  let app: express.Express;&#10;  let server: any;&#10;&#10;  beforeAll(() =&gt; {&#10;    app = express();&#10;    app.use(express.json());&#10;    app.use(express.urlencoded({ extended: false }));&#10;    server = registerRoutes(app);&#10;  });&#10;&#10;  afterAll(() =&gt; {&#10;    server.close();&#10;  });&#10;&#10;  beforeEach(() =&gt; {&#10;    jest.restoreAllMocks();&#10;  });&#10;&#10;  describe('POST /api/analyze', () =&gt; {&#10;    it('should analyze a valid URL with complete SEO tags', async () =&gt; {&#10;      const mockHtml = `&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;          &lt;title&gt;Perfect SEO Page - 50 Characters Long Title&lt;/title&gt;&#10;          &lt;meta name=&quot;description&quot; content=&quot;This is a perfect meta description that is exactly the right length for SEO optimization and provides valuable information about the page content.&quot;&gt;&#10;          &lt;meta name=&quot;robots&quot; content=&quot;index, follow&quot;&gt;&#10;          &lt;meta property=&quot;og:title&quot; content=&quot;Perfect SEO Page - Social Media&quot;&gt;&#10;          &lt;meta property=&quot;og:description&quot; content=&quot;Perfect OG description for social media sharing&quot;&gt;&#10;          &lt;meta property=&quot;og:image&quot; content=&quot;https://example.com/image.jpg&quot;&gt;&#10;          &lt;meta name=&quot;twitter:card&quot; content=&quot;summary_large_image&quot;&gt;&#10;          &lt;meta name=&quot;twitter:title&quot; content=&quot;Perfect SEO Page - Twitter&quot;&gt;&#10;          &lt;meta name=&quot;twitter:description&quot; content=&quot;Perfect Twitter description&quot;&gt;&#10;          &lt;meta name=&quot;twitter:image&quot; content=&quot;https://example.com/twitter-image.jpg&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body&gt;&#10;          &lt;h1&gt;Perfect SEO Page&lt;/h1&gt;&#10;          &lt;p&gt;This is a well-optimized page with all necessary SEO tags.&lt;/p&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;      `;&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body).toHaveProperty('url', 'https://example.com');&#10;      expect(response.body).toHaveProperty('score');&#10;      expect(response.body.score).toBeGreaterThan(90);&#10;      expect(response.body).toHaveProperty('tags');&#10;      expect(response.body).toHaveProperty('breakdown');&#10;      expect(response.body).toHaveProperty('previews');&#10;    });&#10;&#10;    it('should handle missing SEO tags and provide warnings', async () =&gt; {&#10;      const mockHtml = `&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;          &lt;title&gt;Bad&lt;/title&gt;&#10;        &lt;/head&gt;&#10;        &lt;body&gt;&#10;          &lt;h1&gt;Poor SEO Page&lt;/h1&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;      `;&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://bad-seo.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body.score).toBeLessThan(50);&#10;      expect(response.body.breakdown.length).toBeGreaterThan(0);&#10;    });&#10;&#10;    it('should handle completely missing SEO tags', async () =&gt; {&#10;      const mockHtml = `&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;body&gt;&#10;          &lt;h1&gt;No SEO at all&lt;/h1&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;      `;&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://no-seo.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body.score).toBeLessThan(25);&#10;    });&#10;&#10;    it('should handle URLs without protocol by adding https', async () =&gt; {&#10;      const mockHtml = '&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;';&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body.url).toBe('https://example.com');&#10;    });&#10;&#10;    it('should handle network errors gracefully', async () =&gt; {&#10;      jest.spyOn(axios, 'get').mockRejectedValue({ code: 'ENOTFOUND' });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://unreachable.com' })&#10;        .expect(400);&#10;&#10;      expect(response.body.message).toContain('Unable to reach the specified URL');&#10;    });&#10;&#10;    it('should handle 404 errors', async () =&gt; {&#10;      jest.spyOn(axios, 'get').mockRejectedValue({ response: { status: 404 } });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com/nonexistent' })&#10;        .expect(400);&#10;&#10;      expect(response.body.message).toContain('not found (404 error)');&#10;    });&#10;&#10;    it('should handle server errors', async () =&gt; {&#10;      jest.spyOn(axios, 'get').mockRejectedValue({ response: { status: 500 } });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com' })&#10;        .expect(400);&#10;&#10;      expect(response.body.message).toContain('server returned an error');&#10;    });&#10;&#10;    it('should validate request body schema', async () =&gt; {&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ invalidField: 'test' })&#10;        .expect(500);&#10;&#10;      expect(response.body).toHaveProperty('message');&#10;    });&#10;  });&#10;});&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="import { describe, it, expect, beforeAll, afterAll, jest } from '@jest/globals';&#10;import request from 'supertest';&#10;import express from 'express';&#10;import { registerRoutes } from '../routes';&#10;import axios from 'axios';&#10;&#10;describe('SEO Analyzer API', () =&gt; {&#10;  let app: express.Express;&#10;  let server: any;&#10;&#10;  beforeAll(() =&gt; {&#10;    app = express();&#10;    app.use(express.json());&#10;    app.use(express.urlencoded({ extended: false }));&#10;    server = registerRoutes(app);&#10;  });&#10;&#10;  afterAll(() =&gt; {&#10;    server.close();&#10;  });&#10;&#10;  beforeEach(() =&gt; {&#10;    jest.restoreAllMocks();&#10;  });&#10;&#10;  describe('POST /api/analyze', () =&gt; {&#10;    it('should analyze a valid URL with complete SEO tags', async () =&gt; {&#10;      const mockHtml = `&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html lang=&quot;en&quot;&gt;&#10;        &lt;head&gt;&#10;          &lt;title&gt;Perfect SEO Page - 50 Characters Long Title&lt;/title&gt;&#10;          &lt;meta name=&quot;description&quot; content=&quot;This is a perfect meta description that is exactly the right length for SEO optimization and provides valuable information about the page content.&quot;&gt;&#10;          &lt;meta name=&quot;robots&quot; content=&quot;index, follow&quot;&gt;&#10;          &lt;meta property=&quot;og:title&quot; content=&quot;Perfect SEO Page - Social Media&quot;&gt;&#10;          &lt;meta property=&quot;og:description&quot; content=&quot;Perfect OG description for social media sharing&quot;&gt;&#10;          &lt;meta property=&quot;og:image&quot; content=&quot;https://example.com/image.jpg&quot;&gt;&#10;          &lt;meta name=&quot;twitter:card&quot; content=&quot;summary_large_image&quot;&gt;&#10;          &lt;meta name=&quot;twitter:title&quot; content=&quot;Perfect SEO Page - Twitter&quot;&gt;&#10;          &lt;meta name=&quot;twitter:description&quot; content=&quot;Perfect Twitter description&quot;&gt;&#10;          &lt;meta name=&quot;twitter:image&quot; content=&quot;https://example.com/twitter-image.jpg&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body&gt;&#10;          &lt;h1&gt;Perfect SEO Page&lt;/h1&gt;&#10;          &lt;p&gt;This is a well-optimized page with all necessary SEO tags.&lt;/p&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;      `;&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body).toHaveProperty('url', 'https://example.com');&#10;      expect(response.body).toHaveProperty('score');&#10;      expect(response.body.score).toBeGreaterThan(90);&#10;      expect(response.body).toHaveProperty('tags');&#10;      expect(response.body).toHaveProperty('breakdown');&#10;      expect(response.body).toHaveProperty('previews');&#10;    });&#10;&#10;    it('should handle missing SEO tags and provide warnings', async () =&gt; {&#10;      const mockHtml = `&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html lang=&quot;en&quot;&gt;&#10;        &lt;head&gt;&#10;          &lt;title&gt;Bad&lt;/title&gt;&#10;        &lt;/head&gt;&#10;        &lt;body&gt;&#10;          &lt;h1&gt;Poor SEO Page&lt;/h1&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;      `;&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://bad-seo.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body.score).toBeLessThan(50);&#10;      expect(response.body.breakdown.length).toBeGreaterThan(0);&#10;    });&#10;&#10;    it('should handle completely missing SEO tags', async () =&gt; {&#10;      const mockHtml = `&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html lang=&quot;en&quot;&gt;&#10;        &lt;body&gt;&#10;          &lt;h1&gt;No SEO at all&lt;/h1&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;      `;&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://no-seo.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body.score).toBeLessThan(25);&#10;    });&#10;&#10;    it('should handle URLs without protocol by adding https', async () =&gt; {&#10;      const mockHtml = '&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;';&#10;      jest.spyOn(axios, 'get').mockResolvedValue({ data: mockHtml });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com' })&#10;        .expect(200);&#10;&#10;      expect(response.body.url).toBe('https://example.com');&#10;    });&#10;&#10;    it('should handle network errors gracefully', async () =&gt; {&#10;      jest.spyOn(axios, 'get').mockRejectedValue({ code: 'ENOTFOUND' });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://unreachable.com' })&#10;        .expect(400);&#10;&#10;      expect(response.body.message).toContain('Unable to reach the specified URL');&#10;    });&#10;&#10;    it('should handle 404 errors', async () =&gt; {&#10;      jest.spyOn(axios, 'get').mockRejectedValue({ response: { status: 404 } });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com/nonexistent' })&#10;        .expect(400);&#10;&#10;      expect(response.body.message).toContain('not found (404 error)');&#10;    });&#10;&#10;    it('should handle server errors', async () =&gt; {&#10;      jest.spyOn(axios, 'get').mockRejectedValue({ response: { status: 500 } });&#10;&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ url: 'https://example.com' })&#10;        .expect(400);&#10;&#10;      expect(response.body.message).toContain('server returned an error');&#10;    });&#10;&#10;    it('should validate request body schema', async () =&gt; {&#10;      const response = await request(app)&#10;        .post('/api/analyze')&#10;        .send({ invalidField: 'test' })&#10;        .expect(400);&#10;&#10;      expect(response.body).toHaveProperty('message');&#10;    });&#10;  });&#10;&#10;  it('should return 404 for non-existent API path', async () =&gt; {&#10;    const response = await request(app)&#10;      .post('/api/nonexistent')&#10;      .send({})&#10;      .expect(404);&#10;    expect(response.body).toHaveProperty('message');&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/index.ts" />
              <option name="originalContent" value="import express, { type Request, Response, NextFunction } from &quot;express&quot;;&#10;import { registerRoutes } from &quot;./routes&quot;;&#10;import { setupVite, serveStatic, log } from &quot;./vite&quot;;&#10;&#10;const app = express();&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;&#10;app.use((req, res, next) =&gt; {&#10;  const start = Date.now();&#10;  const path = req.path;&#10;  let capturedJsonResponse: Record&lt;string, any&gt; | undefined = undefined;&#10;&#10;  const originalResJson = res.json;&#10;  res.json = function (bodyJson, ...args) {&#10;    capturedJsonResponse = bodyJson;&#10;    return originalResJson.apply(res, [bodyJson, ...args]);&#10;  };&#10;&#10;  res.on(&quot;finish&quot;, () =&gt; {&#10;    const duration = Date.now() - start;&#10;    if (path.startsWith(&quot;/api&quot;)) {&#10;      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;&#10;      if (capturedJsonResponse) {&#10;        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;&#10;      }&#10;&#10;      if (logLine.length &gt; 80) {&#10;        logLine = logLine.slice(0, 79) + &quot;…&quot;;&#10;      }&#10;&#10;      log(logLine);&#10;    }&#10;  });&#10;&#10;  next();&#10;});&#10;&#10;(async () =&gt; {&#10;  const server = await registerRoutes(app);&#10;&#10;  // Register 404 handler for all unknown API routes and methods&#10;  app.all('/api/*', (req, res) =&gt; {&#10;    res.status(404).json({ message: 'Not found' });&#10;  });&#10;&#10;  app.use((err: any, _req: Request, res: Response, _next: NextFunction) =&gt; {&#10;    const status = err.status || err.statusCode || 500;&#10;    const message = err.message || &quot;Internal Server Error&quot;;&#10;&#10;    res.status(status).json({ message });&#10;    throw err;&#10;  });&#10;&#10;  // importantly only setup vite in development and after&#10;  // setting up all the other routes so the catch-all route&#10;  // doesn't interfere with the other routes&#10;  if (app.get(&quot;env&quot;) === &quot;development&quot;) {&#10;    await setupVite(app, server);&#10;  } else {&#10;    serveStatic(app);&#10;  }&#10;&#10;  // ALWAYS serve the app on the port specified in the environment variable PORT&#10;  // Other ports are firewalled. Default to 5000 if not specified.&#10;  // this serves both the API and the client.&#10;  // It is the only port that is not firewalled.&#10;  const port = parseInt(process.env.PORT || '5000', 10);&#10;  server.listen({&#10;    port,&#10;    host: &quot;0.0.0.0&quot;,&#10;    reusePort: true,&#10;  }, () =&gt; {&#10;    log(`serving on port ${port}`);&#10;  });&#10;})();&#10;" />
              <option name="updatedContent" value="import express, { type Request, Response, NextFunction } from &quot;express&quot;;&#10;import { registerRoutes } from &quot;./routes&quot;;&#10;import { setupVite, serveStatic, log } from &quot;./vite&quot;;&#10;&#10;const app = express();&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;&#10;app.use((req, res, next) =&gt; {&#10;  const start = Date.now();&#10;  const path = req.path;&#10;  let capturedJsonResponse: Record&lt;string, any&gt; | undefined = undefined;&#10;&#10;  const originalResJson = res.json;&#10;  res.json = function (bodyJson, ...args) {&#10;    capturedJsonResponse = bodyJson;&#10;    return originalResJson.apply(res, [bodyJson, ...args]);&#10;  };&#10;&#10;  res.on(&quot;finish&quot;, () =&gt; {&#10;    const duration = Date.now() - start;&#10;    if (path.startsWith(&quot;/api&quot;)) {&#10;      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;&#10;      if (capturedJsonResponse) {&#10;        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;&#10;      }&#10;&#10;      if (logLine.length &gt; 80) {&#10;        logLine = logLine.slice(0, 79) + &quot;…&quot;;&#10;      }&#10;&#10;      log(logLine);&#10;    }&#10;  });&#10;&#10;  next();&#10;});&#10;&#10;(async () =&gt; {&#10;  const server = await registerRoutes(app);&#10;&#10;  app.use((err: any, _req: Request, res: Response, _next: NextFunction) =&gt; {&#10;    const status = err.status || err.statusCode || 500;&#10;    const message = err.message || &quot;Internal Server Error&quot;;&#10;&#10;    res.status(status).json({ message });&#10;    throw err;&#10;  });&#10;&#10;  // importantly only setup vite in development and after&#10;  // setting up all the other routes so the catch-all route&#10;  // doesn't interfere with the other routes&#10;  if (app.get(&quot;env&quot;) === &quot;development&quot;) {&#10;    await setupVite(app, server);&#10;  } else {&#10;    serveStatic(app);&#10;  }&#10;&#10;  // ALWAYS serve the app on the port specified in the environment variable PORT&#10;  // Other ports are firewalled. Default to 5000 if not specified.&#10;  // this serves both the API and the client.&#10;  // It is the only port that is not firewalled.&#10;  const port = parseInt(process.env.PORT || '5000', 10);&#10;  server.listen({&#10;    port,&#10;    host: &quot;0.0.0.0&quot;,&#10;    reusePort: true,&#10;  }, () =&gt; {&#10;    log(`serving on port ${port}`);&#10;  });&#10;})();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/routes.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/routes.ts" />
              <option name="originalContent" value="import type { Express } from &quot;express&quot;;&#10;import { createServer, type Server } from &quot;http&quot;;&#10;import { storage } from &quot;./storage&quot;;&#10;import axios from &quot;axios&quot;;&#10;import * as cheerio from &quot;cheerio&quot;;&#10;import { seoAnalysisRequestSchema, type SeoAnalysisResult, type SeoTag, type SeoScoreBreakdown } from &quot;@shared/schema&quot;;&#10;import { ZodError } from &quot;zod&quot;;&#10;&#10;function sanitizeText(text: string): string {&#10;  return text.replace(/&lt;script\b[^&lt;]*(?:(?!&lt;\/script&gt;)&lt;[^&lt;]*)*&lt;\/script&gt;/gi, '')&#10;             .replace(/&lt;[^&gt;]*&gt;/g, '')&#10;             .trim();&#10;}&#10;&#10;function extractDomain(url: string): string {&#10;  try {&#10;    const urlObj = new URL(url);&#10;    return urlObj.hostname;&#10;  } catch {&#10;    return url;&#10;  }&#10;}&#10;&#10;function analyzeSeoTags($: cheerio.CheerioAPI, url: string): {&#10;  tags: SeoTag[];&#10;  breakdown: SeoScoreBreakdown[];&#10;  score: number;&#10;} {&#10;  const tags: SeoTag[] = [];&#10;  const breakdown: SeoScoreBreakdown[] = [];&#10;  let score = 100;&#10;&#10;  // Title analysis&#10;  const title = $('title').first().text().trim();&#10;  if (!title) {&#10;    tags.push({&#10;      tag: &quot;Title&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Title tag is missing&quot;,&#10;      deduction: 25&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Title&quot;,&#10;      issue: &quot;Missing title tag&quot;,&#10;      deduction: 25&#10;    });&#10;    score -= 25;&#10;  } else {&#10;    const titleLength = title.length;&#10;    if (titleLength &lt; 30) {&#10;      tags.push({&#10;        tag: &quot;Title&quot;,&#10;        content: sanitizeText(title),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Title is too short (${titleLength} chars, recommended 50-60)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Title&quot;,&#10;        issue: &quot;Title too short&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else if (titleLength &gt; 60) {&#10;      tags.push({&#10;        tag: &quot;Title&quot;,&#10;        content: sanitizeText(title),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Title is too long (${titleLength} chars, recommended 50-60)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Title&quot;,&#10;        issue: &quot;Title too long&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else {&#10;      tags.push({&#10;        tag: &quot;Title&quot;,&#10;        content: sanitizeText(title),&#10;        status: &quot;good&quot;,&#10;        feedback: `Perfect length (${titleLength} chars)`,&#10;        deduction: 0&#10;      });&#10;    }&#10;  }&#10;&#10;  // Meta description analysis&#10;  const description = $('meta[name=&quot;description&quot;]').attr('content')?.trim() || '';&#10;  if (!description) {&#10;    tags.push({&#10;      tag: &quot;Meta Description&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Meta description is missing&quot;,&#10;      deduction: 20&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Meta Description&quot;,&#10;      issue: &quot;Missing meta description&quot;,&#10;      deduction: 20&#10;    });&#10;    score -= 20;&#10;  } else {&#10;    const descLength = description.length;&#10;    if (descLength &lt; 120) {&#10;      tags.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        content: sanitizeText(description),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Description is too short (${descLength} chars, recommended 150-160)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        issue: &quot;Description too short&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else if (descLength &gt; 160) {&#10;      tags.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        content: sanitizeText(description),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Description is too long (${descLength} chars, recommended 150-160)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        issue: &quot;Description too long&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else {&#10;      tags.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        content: sanitizeText(description),&#10;        status: &quot;good&quot;,&#10;        feedback: `Perfect length (${descLength} chars)`,&#10;        deduction: 0&#10;      });&#10;    }&#10;  }&#10;&#10;  // Meta robots analysis&#10;  const robots = $('meta[name=&quot;robots&quot;]').attr('content')?.trim() || '';&#10;  if (!robots) {&#10;    tags.push({&#10;      tag: &quot;Meta Robots&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Meta robots tag is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Meta Robots&quot;,&#10;      issue: &quot;Missing robots tag&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Meta Robots&quot;,&#10;      content: sanitizeText(robots),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Properly configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  // Open Graph analysis&#10;  const ogTitle = $('meta[property=&quot;og:title&quot;]').attr('content')?.trim() || '';&#10;  const ogDescription = $('meta[property=&quot;og:description&quot;]').attr('content')?.trim() || '';&#10;  const ogImage = $('meta[property=&quot;og:image&quot;]').attr('content')?.trim() || '';&#10;&#10;  if (!ogTitle) {&#10;    tags.push({&#10;      tag: &quot;OG Title&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Open Graph title is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Open Graph&quot;,&#10;      issue: &quot;Missing OG title&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;OG Title&quot;,&#10;      content: sanitizeText(ogTitle),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Present and configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!ogDescription) {&#10;    tags.push({&#10;      tag: &quot;OG Description&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Open Graph description is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Open Graph&quot;,&#10;      issue: &quot;Missing OG description&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;OG Description&quot;,&#10;      content: sanitizeText(ogDescription),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Good content&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!ogImage) {&#10;    tags.push({&#10;      tag: &quot;OG Image&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Open Graph image is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Open Graph&quot;,&#10;      issue: &quot;Missing OG image&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;OG Image&quot;,&#10;      content: ogImage,&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Image present&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  // Twitter Card analysis&#10;  const twitterCard = $('meta[name=&quot;twitter:card&quot;]').attr('content')?.trim() || '';&#10;  const twitterTitle = $('meta[name=&quot;twitter:title&quot;]').attr('content')?.trim() || '';&#10;  const twitterDescription = $('meta[name=&quot;twitter:description&quot;]').attr('content')?.trim() || '';&#10;  const twitterImage = $('meta[name=&quot;twitter:image&quot;]').attr('content')?.trim() || '';&#10;&#10;  if (!twitterCard) {&#10;    tags.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter card type is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing card type&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      content: sanitizeText(twitterCard),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Card type configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!twitterTitle) {&#10;    tags.push({&#10;      tag: &quot;Twitter Title&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter title is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing Twitter title&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Title&quot;,&#10;      content: sanitizeText(twitterTitle),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Present and configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!twitterDescription) {&#10;    tags.push({&#10;      tag: &quot;Twitter Description&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter description is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing Twitter description&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Description&quot;,&#10;      content: sanitizeText(twitterDescription),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Good content&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!twitterImage) {&#10;    tags.push({&#10;      tag: &quot;Twitter Image&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter image is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing Twitter image&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Image&quot;,&#10;      content: twitterImage,&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Image present&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  return {&#10;    tags,&#10;    breakdown,&#10;    score: Math.max(0, score)&#10;  };&#10;}&#10;&#10;export function registerRoutes(app: Express): Server {&#10;  // API Routes&#10;  app.post('/api/analyze', async (req, res) =&gt; {&#10;    try {&#10;      const { url: targetUrl } = seoAnalysisRequestSchema.parse(req.body);&#10;&#10;      // Ensure URL has protocol&#10;      const urlToAnalyze = targetUrl.startsWith('http') ? targetUrl : `https://${targetUrl}`;&#10;&#10;      // Fetch the webpage&#10;      const response = await axios.get(urlToAnalyze, {&#10;        timeout: 10000,&#10;        headers: {&#10;          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'&#10;        }&#10;      });&#10;&#10;      const $ = cheerio.load(response.data);&#10;      const domain = extractDomain(urlToAnalyze);&#10;&#10;      // Analyze SEO tags&#10;      const { tags, breakdown, score } = analyzeSeoTags($, urlToAnalyze);&#10;&#10;      // Extract data for social media previews&#10;      const title = $('title').first().text().trim() || '';&#10;      const description = $('meta[name=&quot;description&quot;]').attr('content')?.trim() || '';&#10;      const ogTitle = $('meta[property=&quot;og:title&quot;]').attr('content')?.trim() || title;&#10;      const ogDescription = $('meta[property=&quot;og:description&quot;]').attr('content')?.trim() || description;&#10;      const ogImage = $('meta[property=&quot;og:image&quot;]').attr('content')?.trim() || '';&#10;      const twitterTitle = $('meta[name=&quot;twitter:title&quot;]').attr('content')?.trim() || ogTitle;&#10;      const twitterDescription = $('meta[name=&quot;twitter:description&quot;]').attr('content')?.trim() || ogDescription;&#10;      const twitterImage = $('meta[name=&quot;twitter:image&quot;]').attr('content')?.trim() || ogImage;&#10;      const twitterCard = $('meta[name=&quot;twitter:card&quot;]').attr('content')?.trim() || 'summary';&#10;&#10;      const result: SeoAnalysisResult = {&#10;        url: targetUrl,&#10;        score,&#10;        breakdown,&#10;        tags,&#10;        previews: {&#10;          google: {&#10;            title: sanitizeText(title),&#10;            description: sanitizeText(description),&#10;            url: targetUrl,&#10;          },&#10;          facebook: {&#10;            title: sanitizeText(ogTitle),&#10;            description: sanitizeText(ogDescription),&#10;            image: ogImage,&#10;            domain: domain,&#10;          },&#10;          twitter: {&#10;            title: sanitizeText(twitterTitle),&#10;            description: sanitizeText(twitterDescription),&#10;            image: twitterImage,&#10;            card: twitterCard,&#10;            domain: domain,&#10;          },&#10;          linkedin: {&#10;            title: sanitizeText(ogTitle),&#10;            description: sanitizeText(ogDescription),&#10;            image: ogImage,&#10;            domain: domain,&#10;          },&#10;        },&#10;      };&#10;&#10;      res.json(result);&#10;    } catch (error) {&#10;      console.error('SEO analysis error:', error);&#10;      if (error instanceof ZodError) {&#10;        return res.status(400).json({ message: &quot;Invalid request body&quot;, errors: error.errors });&#10;      }&#10;      const err = error as any;&#10;      if (err.code === 'ENOTFOUND' || err.code === 'ECONNREFUSED') {&#10;        return res.status(400).json({ message: 'Unable to reach the specified URL. Please check that the URL is correct and accessible.' });&#10;      } else if (err.response?.status === 404) {&#10;        return res.status(400).json({ message: 'The specified page was not found (404 error).' });&#10;      } else if (err.response?.status &amp;&amp; err.response.status &gt;= 400) {&#10;        return res.status(400).json({ message: `The server returned an error: ${err.response.status} ${err.response.statusText}` });&#10;      }&#10;      // Fallback for other errors&#10;      return res.status(500).json({ message: 'An error occurred while analyzing the URL. Please try again.' });&#10;    }&#10;  });&#10;&#10;  const httpServer = createServer(app);&#10;  return httpServer;&#10;}&#10;" />
              <option name="updatedContent" value="import type { Express } from &quot;express&quot;;&#10;import { createServer, type Server } from &quot;http&quot;;&#10;import { storage } from &quot;./storage&quot;;&#10;import axios from &quot;axios&quot;;&#10;import * as cheerio from &quot;cheerio&quot;;&#10;import { seoAnalysisRequestSchema, type SeoAnalysisResult, type SeoTag, type SeoScoreBreakdown } from &quot;@shared/schema&quot;;&#10;import { ZodError } from &quot;zod&quot;;&#10;&#10;function sanitizeText(text: string): string {&#10;  return text.replace(/&lt;script\b[^&lt;]*(?:(?!&lt;\/script&gt;)&lt;[^&lt;]*)*&lt;\/script&gt;/gi, '')&#10;             .replace(/&lt;[^&gt;]*&gt;/g, '')&#10;             .trim();&#10;}&#10;&#10;function extractDomain(url: string): string {&#10;  try {&#10;    const urlObj = new URL(url);&#10;    return urlObj.hostname;&#10;  } catch {&#10;    return url;&#10;  }&#10;}&#10;&#10;function analyzeSeoTags($: cheerio.CheerioAPI, url: string): {&#10;  tags: SeoTag[];&#10;  breakdown: SeoScoreBreakdown[];&#10;  score: number;&#10;} {&#10;  const tags: SeoTag[] = [];&#10;  const breakdown: SeoScoreBreakdown[] = [];&#10;  let score = 100;&#10;&#10;  // Title analysis&#10;  const title = $('title').first().text().trim();&#10;  if (!title) {&#10;    tags.push({&#10;      tag: &quot;Title&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Title tag is missing&quot;,&#10;      deduction: 25&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Title&quot;,&#10;      issue: &quot;Missing title tag&quot;,&#10;      deduction: 25&#10;    });&#10;    score -= 25;&#10;  } else {&#10;    const titleLength = title.length;&#10;    if (titleLength &lt; 30) {&#10;      tags.push({&#10;        tag: &quot;Title&quot;,&#10;        content: sanitizeText(title),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Title is too short (${titleLength} chars, recommended 50-60)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Title&quot;,&#10;        issue: &quot;Title too short&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else if (titleLength &gt; 60) {&#10;      tags.push({&#10;        tag: &quot;Title&quot;,&#10;        content: sanitizeText(title),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Title is too long (${titleLength} chars, recommended 50-60)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Title&quot;,&#10;        issue: &quot;Title too long&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else {&#10;      tags.push({&#10;        tag: &quot;Title&quot;,&#10;        content: sanitizeText(title),&#10;        status: &quot;good&quot;,&#10;        feedback: `Perfect length (${titleLength} chars)`,&#10;        deduction: 0&#10;      });&#10;    }&#10;  }&#10;&#10;  // Meta description analysis&#10;  const description = $('meta[name=&quot;description&quot;]').attr('content')?.trim() || '';&#10;  if (!description) {&#10;    tags.push({&#10;      tag: &quot;Meta Description&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Meta description is missing&quot;,&#10;      deduction: 20&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Meta Description&quot;,&#10;      issue: &quot;Missing meta description&quot;,&#10;      deduction: 20&#10;    });&#10;    score -= 20;&#10;  } else {&#10;    const descLength = description.length;&#10;    if (descLength &lt; 120) {&#10;      tags.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        content: sanitizeText(description),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Description is too short (${descLength} chars, recommended 150-160)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        issue: &quot;Description too short&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else if (descLength &gt; 160) {&#10;      tags.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        content: sanitizeText(description),&#10;        status: &quot;warning&quot;,&#10;        feedback: `Description is too long (${descLength} chars, recommended 150-160)`,&#10;        deduction: 10&#10;      });&#10;      breakdown.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        issue: &quot;Description too long&quot;,&#10;        deduction: 10&#10;      });&#10;      score -= 10;&#10;    } else {&#10;      tags.push({&#10;        tag: &quot;Meta Description&quot;,&#10;        content: sanitizeText(description),&#10;        status: &quot;good&quot;,&#10;        feedback: `Perfect length (${descLength} chars)`,&#10;        deduction: 0&#10;      });&#10;    }&#10;  }&#10;&#10;  // Meta robots analysis&#10;  const robots = $('meta[name=&quot;robots&quot;]').attr('content')?.trim() || '';&#10;  if (!robots) {&#10;    tags.push({&#10;      tag: &quot;Meta Robots&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Meta robots tag is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Meta Robots&quot;,&#10;      issue: &quot;Missing robots tag&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Meta Robots&quot;,&#10;      content: sanitizeText(robots),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Properly configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  // Open Graph analysis&#10;  const ogTitle = $('meta[property=&quot;og:title&quot;]').attr('content')?.trim() || '';&#10;  const ogDescription = $('meta[property=&quot;og:description&quot;]').attr('content')?.trim() || '';&#10;  const ogImage = $('meta[property=&quot;og:image&quot;]').attr('content')?.trim() || '';&#10;&#10;  if (!ogTitle) {&#10;    tags.push({&#10;      tag: &quot;OG Title&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Open Graph title is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Open Graph&quot;,&#10;      issue: &quot;Missing OG title&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;OG Title&quot;,&#10;      content: sanitizeText(ogTitle),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Present and configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!ogDescription) {&#10;    tags.push({&#10;      tag: &quot;OG Description&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Open Graph description is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Open Graph&quot;,&#10;      issue: &quot;Missing OG description&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;OG Description&quot;,&#10;      content: sanitizeText(ogDescription),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Good content&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!ogImage) {&#10;    tags.push({&#10;      tag: &quot;OG Image&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Open Graph image is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Open Graph&quot;,&#10;      issue: &quot;Missing OG image&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;OG Image&quot;,&#10;      content: ogImage,&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Image present&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  // Twitter Card analysis&#10;  const twitterCard = $('meta[name=&quot;twitter:card&quot;]').attr('content')?.trim() || '';&#10;  const twitterTitle = $('meta[name=&quot;twitter:title&quot;]').attr('content')?.trim() || '';&#10;  const twitterDescription = $('meta[name=&quot;twitter:description&quot;]').attr('content')?.trim() || '';&#10;  const twitterImage = $('meta[name=&quot;twitter:image&quot;]').attr('content')?.trim() || '';&#10;&#10;  if (!twitterCard) {&#10;    tags.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter card type is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing card type&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      content: sanitizeText(twitterCard),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Card type configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!twitterTitle) {&#10;    tags.push({&#10;      tag: &quot;Twitter Title&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter title is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing Twitter title&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Title&quot;,&#10;      content: sanitizeText(twitterTitle),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Present and configured&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!twitterDescription) {&#10;    tags.push({&#10;      tag: &quot;Twitter Description&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter description is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing Twitter description&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Description&quot;,&#10;      content: sanitizeText(twitterDescription),&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Good content&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  if (!twitterImage) {&#10;    tags.push({&#10;      tag: &quot;Twitter Image&quot;,&#10;      content: &quot;-&quot;,&#10;      status: &quot;missing&quot;,&#10;      feedback: &quot;Twitter image is missing&quot;,&#10;      deduction: 5&#10;    });&#10;    breakdown.push({&#10;      tag: &quot;Twitter Card&quot;,&#10;      issue: &quot;Missing Twitter image&quot;,&#10;      deduction: 5&#10;    });&#10;    score -= 5;&#10;  } else {&#10;    tags.push({&#10;      tag: &quot;Twitter Image&quot;,&#10;      content: twitterImage,&#10;      status: &quot;good&quot;,&#10;      feedback: &quot;Image present&quot;,&#10;      deduction: 0&#10;    });&#10;  }&#10;&#10;  return {&#10;    tags,&#10;    breakdown,&#10;    score: Math.max(0, score)&#10;  };&#10;}&#10;&#10;export function registerRoutes(app: Express): Server {&#10;  // API Routes&#10;  app.post('/api/analyze', async (req, res) =&gt; {&#10;    try {&#10;      const { url: targetUrl } = seoAnalysisRequestSchema.parse(req.body);&#10;&#10;      // Ensure URL has protocol&#10;      const urlToAnalyze = targetUrl.startsWith('http') ? targetUrl : `https://${targetUrl}`;&#10;&#10;      // Fetch the webpage&#10;      const response = await axios.get(urlToAnalyze, {&#10;        timeout: 10000,&#10;        headers: {&#10;          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'&#10;        }&#10;      });&#10;&#10;      const $ = cheerio.load(response.data);&#10;      const domain = extractDomain(urlToAnalyze);&#10;&#10;      // Analyze SEO tags&#10;      const { tags, breakdown, score } = analyzeSeoTags($, urlToAnalyze);&#10;&#10;      // Extract data for social media previews&#10;      const title = $('title').first().text().trim() || '';&#10;      const description = $('meta[name=&quot;description&quot;]').attr('content')?.trim() || '';&#10;      const ogTitle = $('meta[property=&quot;og:title&quot;]').attr('content')?.trim() || title;&#10;      const ogDescription = $('meta[property=&quot;og:description&quot;]').attr('content')?.trim() || description;&#10;      const ogImage = $('meta[property=&quot;og:image&quot;]').attr('content')?.trim() || '';&#10;      const twitterTitle = $('meta[name=&quot;twitter:title&quot;]').attr('content')?.trim() || ogTitle;&#10;      const twitterDescription = $('meta[name=&quot;twitter:description&quot;]').attr('content')?.trim() || ogDescription;&#10;      const twitterImage = $('meta[name=&quot;twitter:image&quot;]').attr('content')?.trim() || ogImage;&#10;      const twitterCard = $('meta[name=&quot;twitter:card&quot;]').attr('content')?.trim() || 'summary';&#10;&#10;      const result: SeoAnalysisResult = {&#10;        url: targetUrl,&#10;        score,&#10;        breakdown,&#10;        tags,&#10;        previews: {&#10;          google: {&#10;            title: sanitizeText(title),&#10;            description: sanitizeText(description),&#10;            url: targetUrl,&#10;          },&#10;          facebook: {&#10;            title: sanitizeText(ogTitle),&#10;            description: sanitizeText(ogDescription),&#10;            image: ogImage,&#10;            domain: domain,&#10;          },&#10;          twitter: {&#10;            title: sanitizeText(twitterTitle),&#10;            description: sanitizeText(twitterDescription),&#10;            image: twitterImage,&#10;            card: twitterCard,&#10;            domain: domain,&#10;          },&#10;          linkedin: {&#10;            title: sanitizeText(ogTitle),&#10;            description: sanitizeText(ogDescription),&#10;            image: ogImage,&#10;            domain: domain,&#10;          },&#10;        },&#10;      };&#10;&#10;      res.json(result);&#10;    } catch (error) {&#10;      console.error('SEO analysis error:', error);&#10;      if (error instanceof ZodError) {&#10;        return res.status(400).json({ message: &quot;Invalid request body&quot;, errors: error.errors });&#10;      }&#10;      const err = error as any;&#10;      if (err.code === 'ENOTFOUND' || err.code === 'ECONNREFUSED') {&#10;        return res.status(400).json({ message: 'Unable to reach the specified URL. Please check that the URL is correct and accessible.' });&#10;      } else if (err.response?.status === 404) {&#10;        return res.status(400).json({ message: 'The specified page was not found (404 error).' });&#10;      } else if (err.response?.status &amp;&amp; err.response.status &gt;= 400) {&#10;        return res.status(400).json({ message: `The server returned an error: ${err.response.status} ${err.response.statusText}` });&#10;      }&#10;      // Fallback for other errors&#10;      return res.status(500).json({ message: 'An error occurred while analyzing the URL. Please try again.' });&#10;    }&#10;  });&#10;&#10;  // Add 404 handler for unknown API routes&#10;  app.all('/api/*', (req, res) =&gt; {&#10;    res.status(404).json({ message: 'Not found' });&#10;  });&#10;&#10;  const httpServer = createServer(app);&#10;  return httpServer;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>